package ppsim_additions;

import autogenerated_sim.LTo_Module;
import sim.field.grid.ObjectGrid2D;
import sim.util.Double2D;
import sim.util.Int2D;
import simulation_main.Mason_Sim_Main;

public class Setup_Stromal_Cell_Distribution {

	/**
	 * Initialises the grid environment, and calculates how many stromal cells are required
	 * 
	 * @param ppsim	The current simulation state
	 * @param simParams	The simulation parameters read in from the XML file
	 * 
	 */
	public Setup_Stromal_Cell_Distribution()
	{
		// Set up the grid
		Mason_Sim_Main.sim_env.lToGrid = new ObjectGrid2D((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER),(int)(Mason_Sim_Main.simParams.initialGridHeight/Mason_Sim_Main.simParams.LTO_DIAMETER));
		
		// Now determine the experiment being done - are we looking at a normal distribution of LTo cells, or experimentally just one LTo
		
		if(Mason_Sim_Main.simParams.ltoSetup.equals("centreLTo"))
		{
			// EXAMINING ONE IN THIS CASE
			this.insertExperimentalLTo();
		}
		else
		{
			// Normal situation
		
			// Firstly, work out the number of immature stromal cells to create based on the density measure
			
			// Work out what 100% of the cells would be:
			double totalCells = ((((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER)*(int)(Mason_Sim_Main.simParams.initialGridHeight/Mason_Sim_Main.simParams.LTO_DIAMETER))));
			//System.out.println("Total Cells: "+totalCells);
		
			// Now work out what the required number of potentially active stromal cells will need to be placed on the stroma
			double numActiveLTo = (totalCells / 100)*Mason_Sim_Main.simParams.stromalCellDensity;
			//System.out.println("Number Active Cells: "+numActiveLTo);
		
			// add all the LTo cells to the tract, randomly placed
			// However, a certain percentage of these need to be artn active at the start of the simulation - so calculate this number
			double numARTNActive = (numActiveLTo * Mason_Sim_Main.simParams.percentStromaRETLigands)/100;
			//System.out.println("Number ARTN Active: "+numARTNActive);
		
			// Now work out the number of 'decoy' stromal cells that need to be placed on the tract (comes from decoy percentage parameter)
			//double numRLNonStromal = (totalCells / 100)*ppsim.simParams.percentRETLigandNonStromal;
			//System.out.println(numRLNonStromal);
			
			// ADD LTO CELLS
			// ROBOCALC VERSION: Not capturing inactive cells, so we will only distribute the ARTN active number
			this.distribute_LTo_Cells(numARTNActive);
			//this.distribute_LTo_Cells(numActiveLTo);
		
			// SET A PERCENTAGE OF THE LTo CELLS TO EXPRESS RET LIGAND
			// ROBOCALC VERSION: This is done by the state machine
			//this.setCellsExpressingRETLigand(numARTNActive);

			// ADD THE RET LIGAND NON STROMAL CELLS
			// KA removed from robocalc model as not used in the original
			//this.distribute_RLNonStromal_Cells(numRLNonStromal);
		}
	}
	
	/**
	 * Experimental function to place one active LTo in the centre of the simulation
	 * 
	 * @param ppsim	The current simulation state
	 * @param simParams	The current simulation parameters
	 */
	public void insertExperimentalLTo()
	{
		int xLoc = (int)((Mason_Sim_Main.simParams.initialGridLength/2)/Mason_Sim_Main.simParams.LTO_DIAMETER);
		int yLoc = (int)((Mason_Sim_Main.simParams.initialGridHeight/2)/Mason_Sim_Main.simParams.LTO_DIAMETER);
		//System.out.println(xLoc+" "+yLoc);
		
		Int2D gridLocation = new Int2D(xLoc,yLoc);
		// put the object at that location in the grid
		// needs adjusting as boxes are the diameter of the LTo cell - plus add half to correct drawing function
		// else draws on edge of screen
		Double2D location = new Double2D((xLoc*Mason_Sim_Main.simParams.LTO_DIAMETER)+Mason_Sim_Main.simParams.LTO_DIAMETER/2,(yLoc*Mason_Sim_Main.simParams.LTO_DIAMETER)+Mason_Sim_Main.simParams.LTO_DIAMETER/2);
		
		LTo_Module ltoCell = new LTo_Module();
		ltoCell.Init();
		// No need to set entry state as this defaults to start
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionExpressed = 0;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressed = Mason_Sim_Main.simParams.chemoUpperLinearAdjust;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxVCAMProbability = Mason_Sim_Main.simParams.maxVCAMProbability;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.retLigandTime = Mason_Sim_Main.simParams.numHoursRETLigandLToActive;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxExpressionReached = false;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionIncrement = 0.05;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineDecrement = 0.005;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressionLimit = Mason_Sim_Main.simParams.chemoLowerLinearAdjust;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cellDivisionTime = Mason_Sim_Main.simParams.cellDivisionTime;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id = Mason_Sim_Main.agent_store.num_cells_created;
		Mason_Sim_Main.agent_store.num_cells_created++;
		Mason_Sim_Main.agent_store.allCells.put(ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id, ltoCell);
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc = location;
		ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.gridLoc = gridLocation;
					
		Mason_Sim_Main.sim_env.tract.setObjectLocation(ltoCell,location);
		
		ltoCell.setStopper(Mason_Sim_Main.state.schedule.scheduleRepeating(ltoCell,Mason_Sim_Main.agent_store.lto_scheduler_ref,1));
		Mason_Sim_Main.agent_store.lto_scheduler_ref++;
		Mason_Sim_Main.agent_store.ltoCellsBag.add(ltoCell);
		//System.out.println(ltoCell.lto_Attrs.loc);
		
		// set the grid to show the cell has been placed here
		Mason_Sim_Main.sim_env.lToGrid.set(xLoc, yLoc, ltoCell);
		
		
		/*// ADD A SECOND FOR TESTING
		Int2D gridLocation2 = new Int2D(3,3);
		// put the object at that location in the grid
		// needs adjusting as boxes are the diameter of the LTo cell - plus add half to correct drawing function
		// else draws on edge of screen
		location = new Double2D((3*PPsim_robocalc_main.simParams.LTO_DIAMETER)+system_parameters.LTO_DIAMETER/2,(3*system_parameters.LTO_DIAMETER)+system_parameters.LTO_DIAMETER/2);
		LToModule ltoCell2 = new LToModule(location,new Operations(), ppsim, 10);
		ltoCell2.Init();
		ltoCell2.lto_Attrs.gridLoc = gridLocation2;
		tract.setObjectLocation(ltoCell2,ltoCell2.lto_Attrs.loc);
		ltoCell2.setStopper(ppsim.schedule.scheduleRepeating(ltoCell2));
		ppsim.ltoCellsBag.add(ltoCell2);
		System.out.println(ltoCell2.lto_Attrs.loc);
		
		// set the grid to show the cell has been placed here
		ppsim.lToGrid.set(3, 3, ltoCell2);
		*/
	
	}

	
	/**
	 * Adds the required number of LTo cells at random locations in the environment
	 * 
	 * @param ppsim	The current simulation state
	 * @param simParams	The simulation parameters read in from the XML file
	 * @param numActiveLTo	The number of LTo cells that need placing in the environment
	 */
	public void distribute_LTo_Cells(double numActiveLTo)
	{	
		// ADD THE LTo CELLS
		// Each will be placed randomly in the grid
		// So as the length and width have been divided by 6, we can find random grid squares, and fill if not yet chosen
		// Also avoids collision problems
		// Pattern may be box like but will be adjusted as the tract grows
		
		for(int k=0;k<numActiveLTo;k++)   // if the percentage is a decimal, this will be rounded up
		{	
			boolean locationFree = false;
			
			while(!locationFree)
			{
				int xLoc = Mason_Sim_Main.rng.nextInt((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER));
				int yLoc = Mason_Sim_Main.rng.nextInt((int)(Mason_Sim_Main.simParams.initialGridHeight/Mason_Sim_Main.simParams.LTO_DIAMETER));
			
				if(Mason_Sim_Main.sim_env.lToGrid.get(xLoc, yLoc)==null)
				{
					locationFree = true;
					Int2D gridLocation = new Int2D(xLoc,yLoc);
					// put the object at that location in the grid
					// needs adjusting as boxes are the diameter of the LTo cell - plus add half to correct drawing function
					// else draws on edge of screen
					Double2D location = new Double2D((xLoc*Mason_Sim_Main.simParams.LTO_DIAMETER)+Mason_Sim_Main.simParams.LTO_DIAMETER/2,(yLoc*Mason_Sim_Main.simParams.LTO_DIAMETER)+Mason_Sim_Main.simParams.LTO_DIAMETER/2);
										
					LTo_Module ltoCell = new LTo_Module();
					ltoCell.Init();
					// No need to set entry state as this defaults to start
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionExpressed = 0;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressed = Mason_Sim_Main.simParams.chemoUpperLinearAdjust;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxVCAMProbability = Mason_Sim_Main.simParams.maxVCAMProbability;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.retLigandTime = Mason_Sim_Main.simParams.numHoursRETLigandLToActive;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxExpressionReached = false;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionIncrement = 0.05;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineDecrement = 0.005;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressionLimit = Mason_Sim_Main.simParams.chemoLowerLinearAdjust;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cellDivisionTime = Mason_Sim_Main.simParams.cellDivisionTime;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id = Mason_Sim_Main.agent_store.num_cells_created;
					Mason_Sim_Main.agent_store.num_cells_created++;
					Mason_Sim_Main.agent_store.allCells.put(ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id, ltoCell);
					
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc = location;
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.gridLoc = gridLocation;
										
					// add to the bag storing the LTo objects
					Mason_Sim_Main.agent_store.ltoCellsBag.add(ltoCell);
					
					// set the grid to show the cell has been placed here
					Mason_Sim_Main.sim_env.lToGrid.set(xLoc, yLoc, ltoCell);
					
					Mason_Sim_Main.sim_env.tract.setObjectLocation(ltoCell,location);
					
					ltoCell.setStopper(Mason_Sim_Main.state.schedule.scheduleRepeating(ltoCell));
					
				}
			}
		}
	}
	
	/**
	 * KA: Removed from Robocalc model has never used in original
	 * Adds the required number of RLNS cells at random locations in the environment
	 * 
	 * @param ppsim	The current simulation state
	 * @param simParams	The simulation parameters read in from the XML file
	 * @param numDecoys	The number of RLNS cells that need placing in the environment
	 */
	/*public void distribute_RLNonStromal_Cells(double numDecoys)
	{		
		// Now put the decoy cells on the tract
		for(int k=0;k<numDecoys;k++)   // if the percentage is a decimal, this will be rounded up
		{	
			boolean locationFree = false;
		
			while(!locationFree)
			{
				int xLoc = ppsim.random.nextInt((int)(ppsim.simParams.initialGridLength/ppsim.simParams.LTO_DIAMETER));
				int yLoc = ppsim.random.nextInt((int)(ppsim.simParams.initialGridHeight/ppsim.simParams.LTO_DIAMETER));
				
				if(ppsim.lToGrid.get(xLoc, yLoc)==null)
				{
					locationFree = true;
					Int2D gridLocation = new Int2D(xLoc,yLoc);
					// put the object at that location in the grid
					// needs adjusting as boxes are the diameter of the LTo cell - plus add half to correct drawing function
					// else draws on edge of screen
					Double2D location = new Double2D((xLoc*ppsim.simParams.LTO_DIAMETER)+ppsim.simParams.LTO_DIAMETER/2,(yLoc*ppsim.simParams.LTO_DIAMETER)+ppsim.simParams.LTO_DIAMETER/2);
					RLNonStromal decoyCell = new RLNonStromal(location,new Operations(), ppsim, k);
					//decoyCell.Init();
					decoyCell.lto_Attrs.gridLoc = gridLocation;
					
					// add the cell to a collection storing all the decoys
					Simulation_Main.RETLigandNonStromalCellsBag.add(decoyCell);
					
					ppsim.lToGrid.set(xLoc, yLoc, decoyCell);
					
					ppsim.tract.setObjectLocation(decoyCell,location);
					
					decoyCell.setStopper(ppsim.schedule.scheduleRepeating(decoyCell));
				}
			}
		}
	}*/
	
	/**
	 * Sets a percentage of the LTo cells on the stromal to be expressing RET Ligand, and thus have the
	 * potential to become PP
	 * 
	 * @param numARTNActive	Number of LTo cells to set to be expressing RET Ligand
	 */
	public void setCellsExpressingRETLigand(double numARTNActive)
	{
		if(Mason_Sim_Main.simParams.stromalCellRETLigandPlacement.equals("random"))
		{
			// A random selection of LTo cells are set to be expressing RET ligand.  In this case, they can be anywhere on the tract 
			for(int j=0;j<numARTNActive;j++)
			{
				// Pick a random LTo
				int randomLTo = Mason_Sim_Main.rng.nextInt(Mason_Sim_Main.agent_store.ltoCellsBag.size());
			
				// get the LTo from the bag
				LTo_Module ltoCell = (LTo_Module)Mason_Sim_Main.agent_store.ltoCellsBag.get(randomLTo); 
			
				// change the state of the LTo to make this express ARTN if not already expressing ARTN
				if(!ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET)
				{
					ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET = true;
				}
			}
		}
		else
		{
			// RET Ligand expression is restricted to LTo cells in a band.
			// If no LTo cells in a band, then no RET ligand expression.  Means a high enough percentage of the stromal cells must be set to express RET Ligand
			
			// Calculate the available circumference area
			Double rangeHeight = (Mason_Sim_Main.simParams.initialGridHeight/100)*Mason_Sim_Main.simParams.stromalCellCircumferencePercentage;
			
			// Now need to adjust so this range is centered around the centre of the simulation space.
			// Using the middle ensures no cells roll around the screen straight away when a range is used
			Double midpoint = Mason_Sim_Main.simParams.initialGridHeight/2;
			
			for(int j=0;j<numARTNActive;j++)
			{
				int randomLTo = Mason_Sim_Main.rng.nextInt(Mason_Sim_Main.agent_store.ltoCellsBag.size());
				
				// get the LTo from the bag
				LTo_Module ltoCell = (LTo_Module)Mason_Sim_Main.agent_store.ltoCellsBag.get(randomLTo);
				
				if(!ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET)
				{
					if((ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.y >= midpoint-(rangeHeight/2)) && (ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.y <= midpoint+(rangeHeight/2)))
					{
						ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET = true;
					}
				}
			}
			
		}
	}
	
}

