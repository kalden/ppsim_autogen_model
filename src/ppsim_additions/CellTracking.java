package ppsim_additions;

import java.io.FileWriter;
import java.io.IOException;
import java.util.StringTokenizer;

import autogenerated_sim.LTiModule;
import autogenerated_sim.LTin_Module;
import autogenerated_sim.LTo_Module;
import autogenerated_sim.Tracking_Stats;
import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.util.Bag;
import sim.util.Double2D;
import simulation_main.Mason_Sim_Main;

/**
* Class to track cells for a set period in the simulation.  This can be done for a number of periods
* @author kieran
*
*/
public class CellTracking implements Steppable,Stoppable
{	
	private static final long serialVersionUID = 1L;
	
	/**
	 * Boolean stating whether we are in a tracking period or not
	 */
	public boolean inTrackingPeriod = false;
	
	/**
	 * File writer for cells close to a forming patch
	 */
	public FileWriter trackedCells_Close_Writer;
	
	/**
	 * File writer for cells away from a forming patch
	 */
	public FileWriter trackedCells_Away_Writer;
	
	/**
	 * File writer for the summary file, used in batch run situations, where the average of the displacement, length & velocity can then be calculated over
	 * multiple runs
	 */
	//public FileWriter summaryWriter;
	
	public FileWriter tableWriter; 
	
	/**
	 * Average length of cells tracked far from a patch
	 */
	public static double averageLength;
	
	/**
	 * Average velocity of cells tracked far from a patch
	 */
	public static double averageVelocity;
	
	/**
	 * Average displacement of cells tracked far from a patch
	 */
	public static double averageDisplacement;
	
	/**
	 * Average displacement rate of cells tracked far from a patch
	 */
	public static double averageDisplacementRate;
	
	/**
	 * Average meandering index of cells tracked far from a patch
	 */
	public static double averageMeanderingIndex;
	
	/**
	 * Array used to hold the velocities of cells tracked away from a patch - used to calculate variance
	 */
	public static double[] velocities;
	
	/**
	 * Array used to hold the lengths of cells tracked away from a patch - used to calculate variance
	 */
	public static double[] lengths;
	
	/**
	 * Array used to hold the displacement of cells tracked away from a patch - used to calculate variance
	 */
	public static double[] displacements;
	
	
	/**
	 * Initilise the class and the bags in which the tracked cells are stored
	 * 
	 * @param sp	The simulation parameters used in this run
	 * @param ppsim	The current simulation state
	 */
	public CellTracking()
	{		
		
		// Set up the bag that keeps track of the cells being tracked
		Mason_Sim_Main.agent_store.trackedCells_Close = new Bag();
		Mason_Sim_Main.agent_store.trackedCells_Away = new Bag();

	}
	
	
	/**
	 * Begin tracking at the required timepoint.  Where this occurs, cells that are in the far bag, yet are close enough to an LTo to be in the near bag,
	 * are moved as required
	 * 
	 * @param ppsim	The current simulation state
	 */
	/*public void beginTracking()
	{		
		System.out.println("Beginning Tracking");
		for(int k=0;k<PPsim_robocalc_main.trackedCells_Away.size();k++)
		{
			CellModule trackedCell = (CellModule) PPsim_robocalc_main.trackedCells_Away.get(k);
			
			if(findNearestLTo(trackedCell)*4<=50)
			{
				PPsim_robocalc_main.trackedCells_Away.remove(trackedCell);
				PPsim_robocalc_main.trackedCells_Close.add(trackedCell);
				
			}
		}
	}*/
	
	public double get_cell_speed(Object cell)
	{
		if(cell instanceof LTin_Module)
		{
			return((LTin_Module) cell).getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.cellSpeed;
			
		}
		else if(cell instanceof LTiModule)
		{
			return((LTiModule) cell).getLTiModule_LTiStep().LTiStep_LTi_Attributes.cellSpeed;
		}
		else
		{
			return 0;
		}
	}
	
	/**
	 * Output cell tracking results at the end of the tracking period.  These are output as two CSV files - one for close and one for far
	 * 
	 * @param ppsim	The current simulation state
	 * @param cellsTracked	The cells tracked (either far or away)
	 * @param outputTrackStatsWriter	The writer which writes the file
	 */
	public void outputTrackCellsResults(Bag cellsTracked,FileWriter outputTrackStatsWriter, Boolean close)
	{
		// Initialise the averages
		averageDisplacement = 0;
		averageLength = 0;
		averageDisplacementRate = 0;
		averageVelocity = 0;
		averageMeanderingIndex = 0;
		
		
		// TURNED OFF THE 20 FOR THE MOMENT WHILE LOOKING AT STATS OVER TIME
		//if(cellsTracked.size()<20)
		//{
			velocities = new double[cellsTracked.size()];
			displacements = new double[cellsTracked.size()];
			lengths = new double[cellsTracked.size()];
		//}
		//else
		//{
		//	ppsim.velocities = new double[20];
		//	ppsim.displacements = new double[20];
		//	ppsim.lengths = new double[20];
		//}
		
		// Now write out the tracked cells to the file
		
		try
		{
			// stop the output when k=20 so samples can be compared easily on U table
			// TURNED OFF ON 241111 WHILE CELLS TRACKED AWAY BEING EXAMINED IN METHOD OTHER THAN U TEST
			//for(int k=0;k<cellsTracked.size() && k<20;k++)
			//System.out.println("^^^^^^^^^^^^^^^^^^^^^^^ BAG SIZES: "+PPsim_robocalc_main.simParams.allLTins.size()+" "+PPsim_robocalc_main.simParams.allLTis.size());
			//System.out.println("^^^^^^^^^^^^^^^^^^^^^^^ CELLULARITY: "+ PPsim_robocalc_main.simParams.lTinCellularity+" "+PPsim_robocalc_main.simParams.lTiCellularity);
			//System.out.println("^^^^^^^^^^^^^^^^^^^^ CELLS TRACKED SIZE: "+cellsTracked.size());
			for(int k=0;k<cellsTracked.size();k++)
			//for(int k=0;k<cellsTracked.size();k++)
			{
				Tracking_Stats track_info = get_cell_tracking_stats_ref(cellsTracked.get(k));
				
				//System.out.println("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ CELL TIME TRACKED: "+cell_attrs.timeTracked);
				// check that the cell was tracked for an hour
				//if(cell_attrs.timeTracked == 60 && outputStat)
				// Note 61 in RoboChart version - gives one extra step for initialisation
				if(track_info.timeTracked == 61)
				{
					
					// KA IN DEBUG CHANGED THIS TO CELL ID SO WE CAN TIE UP TRACE FILES
					outputTrackStatsWriter.append(Integer.toString(this.get_tracked_cell_id(cellsTracked.get(k)))+",");
					
					/*if(trackedCell instanceof LTinModule)
						outputTrackStatsWriter.append("LTin,");
					else if(trackedCell instanceof LTiModule)
						outputTrackStatsWriter.append("LTi,");*/
					
					// CALCULATE CELL DISPLACEMENT (TAKING INTO ACCOUNT THE CELL MAY HAVE ROLLED AROUND THE SCREEN)
					//double adjuster = 0;
					double trackDisplacement = distanceBetweenTwoPoints(track_info.agentTrackEndLocation,track_info.agentTrackStartLocation,0);
				
					if(trackDisplacement>200)		// must have rolled around the screen, and is therefore incorrect
					{
						if(track_info.agentTrackEndLocation.y<track_info.agentTrackStartLocation.y)
							trackDisplacement = distanceBetweenTwoPoints(track_info.agentTrackEndLocation,track_info.agentTrackStartLocation,254);
						else
							trackDisplacement = distanceBetweenTwoPoints(track_info.agentTrackEndLocation,track_info.agentTrackStartLocation,-254);
					}
					
					// NOW THIS FUNCTION IS USED BOTH BY THE FILE WRITING AND WEB VERSIONS OF THE SIMULATION
					// SO ONLY WRITE TO FILE IF NOT ON THE WEB
					//if(!simParams.webRun)
					//{					
						outputTrackStatsWriter.append(Double.toString(track_info.timeTracked)+",");
			
						// append cell state
						// KA JULY 2018: CELL STATE REMOVED, BLANK TO KEEP OUTPUT STRUCTURE THE SAME
						outputTrackStatsWriter.append("State,");
				
						// append cell speed
						outputTrackStatsWriter.append(Double.toString(get_cell_speed(cellsTracked.get(k))*4)+",");
			
						// append the locations of where the cell started
						outputTrackStatsWriter.append(Double.toString(track_info.agentTrackStartLocation.x)+",");
						outputTrackStatsWriter.append(Double.toString(track_info.agentTrackStartLocation.y)+",");
				
						// append the locations of where the cell ended up
						outputTrackStatsWriter.append(Double.toString(track_info.agentTrackEndLocation.x)+",");
						outputTrackStatsWriter.append(Double.toString(track_info.agentTrackEndLocation.y)+",");
				
						// TRACK LENGTH
						outputTrackStatsWriter.append(Double.toString((track_info.trackLength)*4)+",");

					
						// TRACK VELOCITY - note 61 in robochart version
						outputTrackStatsWriter.append(Double.toString(track_info.trackLength*4/61)+",");
						
							
						// OUTPUT DISPLACEMENT
						outputTrackStatsWriter.append(Double.toString(trackDisplacement*4)+",");
				
					
						// DISPLACEMENT RATE  - note 61 in robochart version
						outputTrackStatsWriter.append(Double.toString(trackDisplacement*4/61)+",");
						// note always divided by 60 as after the displacement rate per minute
						
						// MEANDERING INDEX
						outputTrackStatsWriter.append(Double.toString(trackDisplacement/track_info.trackLength)+",");
					
						// CLOSEST LTO
						outputTrackStatsWriter.append(Double.toString(findNearestLTo(cellsTracked.get(k))*4)+"\n");
						//outputTrackStatsWriter.append("\n");
					//}
					
					// ADD TO THE ARRAYS USED TO DO MANN-WHITNEY
					displacements[k] = trackDisplacement*4;
					velocities[k] = track_info.trackLength*4/60;
					lengths[k] = track_info.trackLength*4;
					
					// ADD TO THE STATS TO CALCULATE AVERAGES
					averageLength += (track_info.trackLength*4);
					averageVelocity += (track_info.trackLength*4)/61; // note 61 in robochart version
					averageDisplacement += (trackDisplacement*4);
					averageDisplacementRate += (trackDisplacement*4/61); // note 61 in robochart version
					averageMeanderingIndex += (trackDisplacement/track_info.trackLength);
				}
			}
			
			// AGAIN SWITCHED OFF TO EXAMINE ALL CELLS TRACKED, NOT FIRST 20
			int divider = 0;
			//if(cellsTracked.size()>20)
			//	divider = 20;
			//else
				divider = cellsTracked.size();
			
			
			averageDisplacement = averageDisplacement/divider;
			averageLength = averageLength/divider;
			averageDisplacementRate = averageDisplacementRate/divider;
			averageVelocity = averageVelocity/divider;
			averageMeanderingIndex = averageMeanderingIndex/divider;
			
			
		}	
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Calculates the distance between two coordinates
	 * 
	 * @param endloc	Where the cell has moved to
	 * @param startloc	Where the cell started
	 * @param adjuster	Adjuster applied to the calculation where the cell has rolled around the screen
	 * @return
	 */
	public double distanceBetweenTwoPoints(Double2D endloc, Double2D startloc, double adjuster)
	{
		return Math.sqrt(
				Math.pow(endloc.x - startloc.x,2)
				+
				Math.pow((endloc.y - startloc.y)+adjuster,2)
				);
	}
	
	/**
	 * Finds nearest LTo cell to the LTin/LTi
	 * 
	 * @param trackedCell	The cell being examined
	 * @param ppsim	The current simulation state
	 * @return	The distance to the nearest LTo
	 */
	public double findNearestLTo(Object trackedCell)
	{
		// now go through each LTo and work out where the nearest active LTo to a tracked cell is
		double closestLTo= Double.POSITIVE_INFINITY;
		double distance;
		
		//System.out.println("Nearest LTo Cells Bag Size: "+PPsim_robocalc_main.ltoCellsBag.size());
		Double2D cell_location = this.get_cell_location(trackedCell);
		
		//System.out.println("Tracked Cell Location: "+cell_attrs.loc);
		
		for(int l=0;l<Mason_Sim_Main.agent_store.ltoCellsBag.size();l++)
		{
			LTo_Module ltoCell = (LTo_Module)Mason_Sim_Main.agent_store.ltoCellsBag.get(l);
			//System.out.println("LTo Location: "+ltoCell.lto_Attrs.loc);
			
	
			if(ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET)
			{
				// calculate the distance from this cell to the LTo
				distance = (Math.sqrt((Math.pow(cell_location.x-ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.x,2)+Math.pow(cell_location.y-ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.y,2))));
				//System.out.println("Distance: "+distance);
				if(distance<closestLTo)
				{
					closestLTo = distance;
				}
			}
			//System.out.println("Closest: "+closestLTo);
	
		}
		return closestLTo;
		
	}
	
	/**
	 * JAY's FUNCTION FOR CHECKING THE INPUT RATE SOLUTION IS WORKING
	 * @param ppsim
	 */
	/*public void generateDataTable()
	{
		try
		{
			
			//if(!simParams.webRun)
			//{ 
				File f = new File(PPsim_robocalc_main.filePath+"/PointsTable.csv");
				if(!f.exists())
				{
					tableWriter = new FileWriter(PPsim_robocalc_main.filePath+"/PointsTable.csv",true);
					tableWriter.append("Time,LTin,LTi\n");
					tableWriter.append(PPsim_robocalc_main.schedule.getSteps()*60+","+PPsim_robocalc_main.simParams.lTinCellularity+","+PPsim_robocalc_main.simParams.lTiCellularity+" \n");
				}
				else
				{
					tableWriter = new FileWriter(PPsim_robocalc_main.filePath+"/PointsTable.csv",true);
				}
				tableWriter.append(ppsim.schedule.getSteps()*60+","+PPsim_robocalc_main.simParams.lTinCellularity+","+PPsim_robocalc_main.simParams.lTiCellularity+" \n");
				tableWriter.close();
			//}
			
		}
		catch (IOException e) 
		{
			e.printStackTrace();
		}
	}*/
	
	
	
	
	/**
	 * Generates a summary file at the run end showing averages of cell measures.  Not really used and may be removed
	 * @param ppsim
	 */
	public void generateStatsAtRunEnd()
	{
		try 
		{	
			//if(!simParams.webRun)
			//{
				//File f = new File(simParams.filePath+"/summary.csv");
				//if(!f.exists())
				//{
					//summaryWriter = new FileWriter(simParams.filePath+"/summary_"+simParams.trackingSnapStartHr+"to"+simParams.trackingSnapEndHr+".csv",true);
					//summaryWriter.append("Run Description,Number Patches >400 Microns,Number Patches > 25 LTi,Average Length Close,Average Velocity Close,Average Displacement Close,Average Displacement Rate Close,Average Meandering Index Close,Average Length Away,Average Velocity Away,Average Displacement Away,Average Displacement Rate Away,Average Meandering Index Away\n");
				//}
				//else
				//{
					//summaryWriter = new FileWriter(simParams.filePath+"/summary.csv",true);
				//}
			
				//this.summaryWriter.append(simParams.description+","+ppsim.numPatchesGreaterThan400Microns+","+ppsim.numPatchesMoreThan25LTi+",");
			
			
				// OUTPUT THE CELL TRACKING STATS TO FILE
				trackedCells_Close_Writer = new FileWriter(Mason_Sim_Main.filePath+"/"+Mason_Sim_Main.runDescription+"/trackedCells_Close_"+Mason_Sim_Main.simParams.trackingSnapStartHr+"to"+Mason_Sim_Main.simParams.trackingSnapEndHr+".csv");
				trackedCells_Close_Writer.append("Cell Type,Time Span,Cell State,Cell Speed,Cell Start Position X,Cell Start Position Y,Cell End Position X,Cell End Position Y,Length,Velocity,Displacement,Displacement Rate,Meandering Index,Nearest LTo Cell (microns)\n");
			
				trackedCells_Away_Writer = new FileWriter(Mason_Sim_Main.filePath+"/"+Mason_Sim_Main.runDescription+"/trackedCells_Away_"+Mason_Sim_Main.simParams.trackingSnapStartHr+"to"+Mason_Sim_Main.simParams.trackingSnapEndHr+".csv");
				trackedCells_Away_Writer.append("Cell Type,Time Span,Cell State,Cell Speed,Cell Start Position X,Cell Start Position Y,Cell End Position X,Cell End Position Y,Length,Velocity,Displacement,Displacement Rate,Meandering Index,Nearest LTo Cell (microns)\n");
			//}
			
			// Now use the utility class to create the output files and process the cell objects													
			/*PP_CSVFileWriter.initialiseOutputFile(PPsim_robocalc_main.filePath+"/"+PPsim_robocalc_main.runDescription+"/",
					"/trackedCells_Close_"+PPsim_robocalc_main.simParams.trackingSnapStartHr+"to"+PPsim_robocalc_main.simParams.trackingSnapEndHr+"New.csv",
					PPsim_robocalc_main.simParams.cellResponseMeasures);
			PP_CSVFileWriter.processSimulationResponses(PPsim_robocalc_main.trackedCells_Close);
			
			PP_CSVFileWriter.initialiseOutputFile(PPsim_robocalc_main.filePath+"/"+PPsim_robocalc_main.runDescription+"/",
					"/trackedCells_Away_"+PPsim_robocalc_main.simParams.trackingSnapStartHr+"to"+PPsim_robocalc_main.simParams.trackingSnapEndHr+"New.csv",
					PPsim_robocalc_main.simParams.cellResponseMeasures);
			PP_CSVFileWriter.processSimulationResponses(PPsim_robocalc_main.trackedCells_Away);*/

			
			
			// RUN THE OUTPUT CELL TRACKS WHETHER WRITING TO FILE OR NOT - USED BY BOTH THE WEB AND NON WEB VERSIONS
			// write the tracks of cells close to the stromal cells
		    //System.out.println("Size of Close Away: "+PPsim_robocalc_main.trackedCells_Close.numObjs+" "+PPsim_robocalc_main.trackedCells_Away.numObjs);
			this.outputTrackCellsResults(Mason_Sim_Main.agent_store.trackedCells_Close,trackedCells_Close_Writer, true);
			/*
			ppsim.averageLengthNear = ppsim.averageLength;
			ppsim.averageVelocityNear = ppsim.averageVelocity;
			ppsim.averageDisplacementNear = ppsim.averageDisplacement;
			ppsim.averageDisplacementRateNear = ppsim.averageDisplacementRate;
			ppsim.averageMeanderingIndexNear = ppsim.averageMeanderingIndex;
			
			ppsim.velocitiesNear = ppsim.velocities;
			ppsim.displacementsNear = ppsim.displacements;
			ppsim.lengthsNear = ppsim.lengths;*/
			
			//if(!simParams.webRun)
			//{
				//this.summaryWriter.append(ppsim.averageLength+","+ppsim.averageVelocity+","+ppsim.averageDisplacement+","+ppsim.averageDisplacementRate+","+ppsim.averageMeanderingIndex+",");
			//}
			
			// write the tracks of the cells away from the stromal cell
			this.outputTrackCellsResults(Mason_Sim_Main.agent_store.trackedCells_Away,trackedCells_Away_Writer, false);
			
			trackedCells_Close_Writer.close();
			trackedCells_Away_Writer.close();
			
			/*
			if(!simParams.webRun)
			{
				//this.summaryWriter.append(ppsim.averageLength+","+ppsim.averageVelocity+","+ppsim.averageDisplacement+","+ppsim.averageDisplacementRate+","+ppsim.averageMeanderingIndex+"\n");
			
				
				//summaryWriter.close();
			}*/
			
			
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		
	}
	
	public Tracking_Stats get_cell_tracking_stats_ref(Object cell)
	{
		if(cell instanceof LTin_Module)
		{
			return((LTin_Module) cell).getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.tracking;
			
		}
		else if(cell instanceof LTiModule)
		{
			return((LTiModule) cell).getLTiModule_LTiStep().LTiStep_LTi_Attributes.tracking;
		}
		else
		{
			return null;
		}
	}
	
	public int get_tracked_cell_id(Object cell)
	{
		if(cell instanceof LTin_Module)
		{
			return((LTin_Module) cell).getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.cell_id;
			
		}
		else if(cell instanceof LTiModule)
		{
			return((LTiModule) cell).getLTiModule_LTiStep().LTiStep_LTi_Attributes.cell_id;
		}
		else
		{
			return 0;
		}
	}
	
	public Double2D get_cell_location(Object cell)
	{
		if(cell instanceof LTin_Module)
		{
			return((LTin_Module) cell).getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.LTin_loc;
			
		}
		else if(cell instanceof LTiModule)
		{
			return((LTiModule) cell).getLTiModule_LTiStep().LTiStep_LTi_Attributes.LTi_loc;
		}
		else
		{
			return null;
		}
	}

	/**
	 * Performed each step in the simulation - monitors the two tracked bags during cell tracking, moving cells between them as necessary
	 */
	public void step(final SimState state)
	{
		// while the simulation is running
		if(state.schedule.getSteps() < (Mason_Sim_Main.simParams.simulationTime))
		{
			
			/*if(ppsim.schedule.getSteps()==1)
			{
				System.out.println("chemoUpperLinearAdjust: "+ppsim.simParams.chemoUpperLinearAdjust);
				System.out.println("chemoLowerLinearAdjust: "+ppsim.simParams.chemoLowerLinearAdjust);
				System.out.println("maxVCAMeffectProbabilityCutoff: "+ppsim.simParams.maxVCAMProbability);
				System.out.println("chemoThreshold: "+ppsim.simParams.chemoThreshold);
				System.out.println("vcamSlope: "+ppsim.simParams.vcamSlope);
			}*/
			//System.out.println("*************** STEP: "+ppsim.schedule.getSteps());
			
			if(Mason_Sim_Main.simParams.cellTrackingEnabled)
			{
				//System.out.println("Tracking Snap Start Hour: "+PPsim_robocalc_main.simParams.trackingSnapStartHr);
				//System.out.println("Output: "+PPsim_robocalc_main.filePath+" Des: "+PPsim_robocalc_main.runDescription);
				
				// THERE WILL BE CELLS IN THE BAG BEING TRACKED, THOUGH TRACKING IS YET TO START
				// SET THE TRACK START LOCATION OF ALL OF THESE CELLS NOW THE TIME HAS COMMENCED
				// IF MULTIPLE TRACKING RANGES ARE USED, BOTH BAGS WILL NEED TO BE RESET
				if(state.schedule.getSteps() == (Mason_Sim_Main.simParams.trackingSnapStartHr*60) || state.schedule.getSteps() == 0)
				//if(ppsim.schedule.getSteps() == (PPsim_robocalc_main.simParams.trackingSnapStartHr*60))
				{	
					//System.out.println("Beginning Tracking");
					inTrackingPeriod = true;
					
					for(int k=0;k<Mason_Sim_Main.agent_store.trackedCells_Away.size();k++)
					{
						// Get the tracking stats reference for this cell
						Tracking_Stats track_info = get_cell_tracking_stats_ref(Mason_Sim_Main.agent_store.trackedCells_Away.get(k));
												
						track_info.agentTrackStartLocation = get_cell_location(Mason_Sim_Main.agent_store.trackedCells_Away.get(k));
						track_info.agentTrackEndLocation = null;
						track_info.timeTracked = 0;
						track_info.trackLength = 0;
					}
					
					for(int k=0;k<Mason_Sim_Main.agent_store.trackedCells_Close.size();k++)
					{
						// Get the tracking stats reference for this cell
						Tracking_Stats track_info = get_cell_tracking_stats_ref(Mason_Sim_Main.agent_store.trackedCells_Close.get(k));
						
						track_info.agentTrackStartLocation = get_cell_location(Mason_Sim_Main.agent_store.trackedCells_Close.get(k));
						track_info.agentTrackEndLocation = null;
						track_info.timeTracked = 0;
						track_info.trackLength = 0;
									
						
						// In debugging, set up the close debug trace file
						/*if(PPsim_robocalc_main.trace_files_output)
						{
							System.out.println("Initialising Trace File Step "+cell_attrs.ppsim.schedule.getSteps());
							cell_attrs.refToObject.initialise_close_trace_file(cell_attrs.cellID, PPsim_robocalc_main.simParams.trackingSnapStartHr);
						} */
					}
				}
				
				
				// TRACKING HAS NOW ENDED - ADD THE END LOCATION FOR ALL CELLS THAT ARE STILL BEING TRACKED
				else if(state.schedule.getSteps() == (Mason_Sim_Main.simParams.trackingSnapEndHr*60))
				//else if(ppsim.schedule.getSteps() > 60)
				{
					//System.out.println("ENDED");
					
					inTrackingPeriod = false;
					for(int k=0;k<Mason_Sim_Main.agent_store.trackedCells_Away.size();k++)
					{
						// Get the tracking stats reference for this cell
						Tracking_Stats track_info = get_cell_tracking_stats_ref(Mason_Sim_Main.agent_store.trackedCells_Away.get(k));
						
						if(track_info.agentTrackEndLocation == null)
						{
							track_info.agentTrackEndLocation = get_cell_location(Mason_Sim_Main.agent_store.trackedCells_Away.get(k));
						}
					}
					
					for(int k=0;k<Mason_Sim_Main.agent_store.trackedCells_Close.size();k++)
					{
						// Get the tracking stats reference for this cell
						Tracking_Stats track_info = get_cell_tracking_stats_ref(Mason_Sim_Main.agent_store.trackedCells_Close.get(k));
						
						if(track_info.agentTrackEndLocation == null)
						{
							track_info.agentTrackEndLocation = get_cell_location(Mason_Sim_Main.agent_store.trackedCells_Close.get(k));
						}
						
						
						// In debugging, end the trace
						/*if(cell_attrs.refToObject.close_behaviour_writer != null)
						{
							cell_attrs.refToObject.end_close_trace_file();
						}*/
					}
					
					// NOW TRACKING HAS ENDED, PREPARE FOR THE NEXT TRACKING RANGE
					// FIRSTLY OUTPUT THE CURRENT TRACKED RANGE
					this.generateStatsAtRunEnd();
					
					// NOW GENERATE EXPRESSION
					//ppsim.cellexp.generateExpressionStats(ppsim);
					
					// set the next range (if there is one)
					if(!Mason_Sim_Main.simParams.trackingHourRanges.isEmpty())
					{
						StringTokenizer st = new StringTokenizer(Mason_Sim_Main.simParams.trackingHourRanges.get(0),"-");
						Mason_Sim_Main.simParams.trackingSnapStartHr = Integer.parseInt(st.nextToken());
						Mason_Sim_Main.simParams.trackingSnapEndHr = Integer.parseInt(st.nextToken());
						Mason_Sim_Main.simParams.trackingHourRanges.remove(0);
					}
					
					
					//if(!simParams.trackingStartHours.isEmpty())
					//{
						//simParams.trackingSnapStartHr = simParams.trackingStartHours.get(0);
						//simParams.trackingSnapEndHr = simParams.trackingEndHours.get(0);
					//}
				}
			}
			
			// CALL TO JAY'S METHOD TO CHECK THE CELLULARITY IN THE SYSTEM
			//if (ppsim.schedule.getSteps()%60 == 0)
			//{
				//generateDataTable(ppsim);
			//}
			
		}
		else
		{
			this.stop();
		}
		
	}
	
	/**
	 * Flag to show if this class has been stopped (when no longer needed)
	 */
	private Stoppable stopper = null;
	
	/**
	 * Method to change the value of the stopper
	 * @param stopper	Whether the class should be stopped or not
	 */
   public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
   
   /**
    * Method to stop the class where necessary
    */
   public void stop(){stopper.stop();}
}
