package autogenerated_sim;

import java.util.ArrayList;
import java.util.SortedMap;

import autogenerated_sim.LTiModule;
import autogenerated_sim.LTin_Module;
import autogenerated_sim.LTo_Module;
import simulation_main.Mason_Sim_Main;
import sim.util.Bag;
import sim.util.Double2D;
import sim.util.Int2D;
import sim.util.IntBag;

public class Functions {

public static int calculate_high_grid_square(SortedMap<Double, Integer> chemomap)
{
	return chemomap.get(chemomap.lastKey());
}
	
    
public static double calculate_angle_from_direction(int direction)
{
	double angle=0.0;
	
	double r =  Mason_Sim_Main.rng.nextDouble();
		 
		
	// Now calculate the angle
	// See diagram of how this was calculated if necessary
	switch(direction)
	{
		case 0:angle = Math.toRadians(203 +(r * ((249 - 203) + 1)));break;
		case 1:angle = Math.toRadians(158 +(r * ((202 - 158) + 1)));break;
		case 2:angle = Math.toRadians(113 +(r * ((157 - 113) + 1)));break;
		case 3:angle = Math.toRadians(250 +(r * ((292 - 250) + 1)));break;
		// No case four as this is where the cell currently is
		case 5:angle = Math.toRadians(68 +(r * ((112 - 68) + 1)));break;
		case 6:angle = Math.toRadians(293 +(r * ((337 - 293) + 1)));break;
		
		// Note special case 7 as this involves angle range 338-360 and 0-22
		case 7:angle = 0 +(r * ((45 - 0) + 1));
			if(angle>22)
				angle=angle+337;
	
		angle = Math.toRadians(angle);
		break;
		
		case 8:angle = Math.toRadians(23 +(r * ((67 - 23) + 1)));break;
		
		// chosen square may also have been sent in as 99 - signifying a random angle should be chosen
		case 99:angle = Math.toRadians(0 +(r * ((360) + 1)));break;
	 }
		
	 return angle;
}
	
    
public static int collision_check(Double2D cell_loc, Tracking_Stats tracking, int cell_id, String cellType)
{
Bag cellsInRange = Mason_Sim_Main.sim_env.tract.getObjectsExactlyWithinDistance(cell_loc,((Mason_Sim_Main.simParams.HCELL_DIAMETER/2)+(Mason_Sim_Main.simParams.LTO_DIAMETER/2)));
	
	// 2 - GO THROUGH THE LIST IF NOT NULL
	
	//boolean collision = false;		// flag to return if there is a collision
	
	if( cellsInRange != null )
	{
		
		// Now determine if there is contact with LTo cells
		// go through all potential clashes, avoiding itself
		for( int i = 0 ; i < cellsInRange.numObjs; i++ )
		{
			//LToModule temp = (LToModule)cellsInRange.get(i);
			Object temp = cellsInRange.get(i);
			int temp_id = return_cell_id(temp);
			
			// check cell is not null or the cell is itself
			if(temp!=null && temp_id != cell_id)
			{
				// check whether the cell is an immature LTo
				// IF not used in robocalc version
				/*if(temp instanceof LTo && temp.cellState==0 && this instanceof LTi && this.cellState==8)
				{
					// here, an LTi that has been in contact with an LTo is in contact with an immature cell
					// that it may activate (if within a certain distance). Call the method which increases
					// the contact count and activates the LTo if necessary
					//System.out.println("temp cell state 0");
					this.immatureLToActivation(ppsim,(LTo)temp);
				}*/
				if(temp instanceof LTo_Module) 
				{
					LTo_Module lto = (LTo_Module)temp;
					
					/*if(cell_attrs.traceOutput)
					{
						cell_attrs.refToObject.write_to_trace_file("Cell at Position: "+i+" "+lto.lto_Attrs.loc);
					}*/
					
					if(lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET)
					{
						//if(cell_attrs.traceOutput)
						//	cell_attrs.refToObject.write_to_trace_file("In Collision Check, temp instance of LTo and expressing RET");
						
						// NOW WORK OUT IF THIS CONTACT 'ACTIVATES' THE LTO
						// SIMULATES A 'BIND STRENGTH
						// 16/12/10
						// FIRSTLY NEED TO CHECK WHETHER THIS CONTACT CHANGES STATE (BASED ON A PROBABILITY)
						double probability =  Mason_Sim_Main.rng.nextInt(100);
					
						
						/*if(cell_attrs.traceOutput)
						{
							cell_attrs.refToObject.write_to_trace_file("Temp is LTo and in Correct Cell State");
							cell_attrs.refToObject.write_to_trace_file("Probability: "+probability+" Limit: "+PPsim_robocalc_main.simParams.thresholdBindProbability);
						}*/
							
						if(probability<=(Mason_Sim_Main.simParams.thresholdBindProbability*100))
						{
							// THE BIND HOLDS
							//collision = true;
							
							if(cellType.equals("LTin") && !Mason_Sim_Main.simParams.retLigandKnockOut)
							{
								// DO I NEED TO DO SOMETHING TO THE LTO HERE
								
								// perform the art/ret signal & cell state change if required
								//this.artnRETSignalling(ppsim);
								
								if(Mason_Sim_Main.simParams.cellTrackingEnabled)
								{
									if(!Mason_Sim_Main.agent_store.trackedCells_Close.contains(Mason_Sim_Main.agent_store.allCells.get(cell_id)))
									{
										//System.out.println("Moving Cell "+cell_attrs.cellID+" from Away to Close");
										// Get the LTin cell
										LTin_Module ltin_cell = (LTin_Module) Mason_Sim_Main.agent_store.allCells.get(cell_id);
										Mason_Sim_Main.agent_store.trackedCells_Away.remove(ltin_cell);
										ltin_cell.getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.tracking.trackLength = 0;
										ltin_cell.getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.tracking.timeTracked = 0;
										ltin_cell.getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.tracking.agentTrackStartLocation = cell_loc;
										Mason_Sim_Main.agent_store.trackedCells_Close.add(Mason_Sim_Main.agent_store.allCells.get(cell_id));
										
										// If we're adding to this list during tracking, the trace file will not be set up - need to do that
										/*if(PPsim_robocalc_main.inTrackingPeriod && PPsim_robocalc_main.trace_files_output)
										{
											cell_attrs.refToObject.initialise_close_trace_file(cell_attrs.cellID, PPsim_robocalc_main.simParams.trackingSnapStartHr );
										}*/
										
									}
								}
							
								// stick the LTin/LTi to the LTo
								//if(simParams.oneStepAdhesion)
								//	this.adhesionTime = 2;
								//else
									//this.adhesionTime = 1;
							
								// DEAL WITH LTo SIGNALLING & STATE CHANGES IF NECESSARY CAUSED BY BIND
								lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.new_LTin_binding = true;
								
								// KA 190418 - Attempt here to sync LTo state changing - increments now done here, not in the state machine
								lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.lTinContactStateChangeTimePoint = (int) Mason_Sim_Main.state.schedule.getSteps();
								// KA 210818 - This increment will now be done in the LTo, where it should have been 
								//lto.increment_adhesion();
								
								
								//this.updateLToState((LTo)this.contactedCell,this,(int)ppsim.schedule.getSteps(),simParams.vcamSlope,simParams.maxVCAMeffectProbabilityCutoff);
								
								// store this as the cell the LTin is in contact with - will need this to calculate VCAM in next step
								// there has been a collision - now determine if the cell is a 'decoy' - expressing RET Ligand as 
								// an LTo is - if this is the case, the cell is assumed to have made contact for the surface adhesion step
								return return_cell_id(temp);
								
								//if(cell_state instanceof LTin_State_Machine)
								//	((LTin_State_Machine) (cell_state)).contactedCell_ID = return_cell_id(temp);
								//else if(cell_state instanceof LTi_State_Machine)
								//	((LTi_State_Machine) (cell_state)).contactedCell_ID = return_cell_id(temp);
																		
								
							}
						
							if(cellType.equals("LTi") && lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.lTinContactStateChangeTimePoint>-1)			// LTi cells will stick if VCAM level high enough, & produce chemokines
							{
								//System.out.println("YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY");
								
								//this.alterLTiState(ppsim,(LTo)temp);
								
								if(Mason_Sim_Main.simParams.cellTrackingEnabled)
								{
									if(!Mason_Sim_Main.agent_store.trackedCells_Close.contains(Mason_Sim_Main.agent_store.allCells.get(cell_id)))
									{
										// Get the LTi cell
										LTiModule lti_cell = (LTiModule) Mason_Sim_Main.agent_store.allCells.get(cell_id);
										Mason_Sim_Main.agent_store.trackedCells_Away.remove(Mason_Sim_Main.agent_store.allCells.get(cell_id));
										lti_cell.getLTiModule_LTiStep().LTiStep_LTi_Attributes.tracking.trackLength = 0;
										lti_cell.getLTiModule_LTiStep().LTiStep_LTi_Attributes.tracking.timeTracked = 0;
										lti_cell.getLTiModule_LTiStep().LTiStep_LTi_Attributes.tracking.agentTrackStartLocation = cell_loc;
										Mason_Sim_Main.agent_store.trackedCells_Close.add(Mason_Sim_Main.agent_store.allCells.get(cell_id));
										
									}
								}
								
								lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.new_LTi_binding = true;
								
								// KA 190418 - Attempt here to sync chemokine changing
								lto.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.lTiContactStateChangeTimePoint = (int) Mason_Sim_Main.state.schedule.getSteps();
								// KA 210818 - This increment will now be done in the LTo, where it should have been
								//lto.increment_chemokine_expression();
								
								//this.updateLToState((LTo)this.contactedCell,this,(int)ppsim.schedule.getSteps(),simParams.vcamSlope,simParams.maxVCAMeffectProbabilityCutoff);
								
								// store this as the cell the LTin is in contact with - will need this to calculate VCAM in next step
								//if(cell_state instanceof LTin_State_Machine)
								//	((LTin_State_Machine) (cell_state)).contactedCell_ID = return_cell_id(temp);
								//else if(cell_state instanceof LTi_State_Machine)
								//	((LTi_State_Machine) (cell_state)).contactedCell_ID = return_cell_id(temp);
								return return_cell_id(temp);
								
								
								//if(simParams.oneStepAdhesion)
									//this.adhesionTime = 2;
								//else
									//this.adhesionTime = 1;
								
								// store this as the cell the LTin is in contact with - will need this to calculate VCAM in next step
								//this.contactedCell = temp;
							
								// DEAL WITH LTo SIGNALLING & STATE CHANGES IF NECESSARY CAUSED BY BIND
								//this.updateLToState((LTo)this.contactedCell,this,(int)ppsim.schedule.getSteps(),simParams.vcamSlope,simParams.maxVCAMeffectProbabilityCutoff);
							}
							
							
						}
						/*else
						{
							if(cell_attrs.traceOutput)
							{
								cell_attrs.refToObject.write_to_trace_file("Cells Don't Bind");
							}
						}*/
					}
				}
				
				// KA 140318: Taken out for the moment as not detected in this method in robocalc
				// Now check if the cell is in contact with a decoy RET Ligand cell on the tract surface
				/*else if(temp instanceof RLNonStromal && !simParams.retLigandKnockOut)
				{
					int probability = ppsim.random.nextInt(100)+1;
					
					if(probability<=simParams.thresholdBindProbability)	// the cell will move but remain in contact, held by vcam
					{
						collision = true;
						// the cell will 'stick', so adjust the adhesion time & contact cell variables
						//if(simParams.oneStepAdhesion)
							//this.adhesionTime = 2;
						//else
							//this.adhesionTime = 1;
						
						this.contactedCell = temp;
						
						this.contactedCell.vcamAdhesionEffect.increaseVCAMExpressionLevel(simParams.vcamIncrement);
						
						
						
						
					}
					
				}*/
			}
		}
	}
	// No contact, so can return -1 as the ID
	//return collision;
	return -1;
}
	
    
public static double measure_chemokine_expression(Double2D loc, SortedMap<Double, Integer> chemomap)
{
	// Store the total of each of the probabilities - used in later calculations to
	// standardise the probability
	double totalchemoLevels = 0;
	
	if (!Mason_Sim_Main.simParams.chemoKnockOut) 
	{
		// Firstly, calculate the moores neighbourhood around the cell
		// System.out.println(agentLocation.x+" "+agentLocation.y);
		IntBag mooresX = Mason_Sim_Main.sim_env.chemoGrid.generateMooresN(loc.x, loc.y, true);
		IntBag mooresY = Mason_Sim_Main.sim_env.chemoGrid.generateMooresN(loc.x, loc.y, false);
		// System.out.println("Agent Location: "+agentLocation);
		// System.out.println("Rounded: "+chemoGrid.roundX(agentLocation.x, ppsim)+"
		// "+chemoGrid.roundY(agentLocation.y, ppsim));

		// Store the total of each of the probabilities - used in later calculations to
		// standardise the probability
		//double totalchemoLevels = 0;

		// clear the map used to calculate the move
		chemomap.clear();

		// Now go through each grid in the neighbourhood, excluding the centre where the
		// cell is
		
		
		for (int k = 0; k < mooresX.size(); k++) {
			// FIX 170311 - DUE TO THE TOROIDAL NATURE OF NEIGHBOURS (AS THE CELLS CAN MOVE
			// BOTTOM ROUND TO TOP, THEY WILL BE ABLE TO MOVE ROUND THE EDGES
			// OF THE SCREEN (LEFT & RIGHT) - THIS NEEDS TO BE STOPPED - SO THE LEVEL OF
			// CHEMOKINE FOR GRID SPACES THE OPPOSITE SIDE OF THE SCREEN IS NOT
			// CALCULATED

			// ONLY LOOK AT THIS SQUARE IF NOT ROLLED AROUND THE SCREEN
			boolean moveOk = checkChemokineRightLeftRollAround(loc,  mooresX.get(k));

			if (moveOk) {
				// store the highest effect for this cell
				double chemoHighEffect = 0.0;

				// Just check that this is not the middle cell of the neighbourhood (where the
				// cell is)
				if ((mooresX.get(k) != Mason_Sim_Main.sim_env.chemoGrid.roundX(loc.x))
						|| (mooresY.get(k) != Mason_Sim_Main.sim_env.chemoGrid.roundY(loc.y))) {
					// Now look at each LTo Cell and examine the chemokine effect (Note, strongest
					// may not be closest)
					for (int l = 0; l < Mason_Sim_Main.agent_store.ltoCellsBag.size(); l++) {
						LTo_Module ltoCell = (LTo_Module) Mason_Sim_Main.agent_store.ltoCellsBag.get(l);

						if (ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET
								& ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.lTiContactStateChangeTimePoint != -1) {
							// Firstly calculate the distance from the LTo Cell - this is needed for all
							// calculations
							double distance = (Math.sqrt((Math.pow(mooresX.get(k) - ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.x, 2)
									+ Math.pow(mooresY.get(k) - ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc.y, 2))));

							// Firstly check if this or the chemokine has been knocked out
							double chemoEffect = 0;
							if (!Mason_Sim_Main.simParams.chemoKnockOut) {
								chemoEffect = calcChemoLevel(distance, ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressed,
										Mason_Sim_Main.simParams.chemoSigThreshold,
										Mason_Sim_Main.simParams.chemoThreshold);

								// determine if this is the highest effect seen, if so change the variable
								if (chemoEffect > chemoHighEffect)
									chemoHighEffect = chemoEffect;
							}
						}
						else
						{
							//if (traceOutput)
								//cell.write_to_trace_file("Fail on Expressing RET or LTi Contact State Change Timepoint "+ ltoCell.lto_Attrs.expressing_RET+" "+ltoCell.lto_Attrs.lTiContactStateChangeTimePoint);
						}
					} // has finished looking at each LTo

					// Now for that square, add the level to the map for processing later in
					// calculation of the move
					chemomap.put(chemoHighEffect * 100, k);
					// System.out.println("K: "+k+" "+chemoHighEffect*100);
					totalchemoLevels += chemoHighEffect;
				}

				else // looking at the middle square, where the cell currently is
				{
					chemomap.put(0.0, k);

				}
			}

		} // has finished looking at every square

		/*if (cell_attrs.get_module_ref().traceOutput)
			cell_attrs.get_module_ref().cell_trace.write_to_trace_file("Total Chemokine Level: " + cell_attrs.totalchemoLevels);*/
		
		return totalchemoLevels;
		//return cell_attrs.chemomap.get(cell_attrs.chemomap.lastKey());
	}
	else
	{
		// Return a high chemokine direction of -1, to signify no chemokine
		//return -1;
		return 0;
	}
}
	
    
public static Double2D calculateNewPosition(Double2D cell_loc, double angle_to_move, double movement_interval)
{
	//System.out.println("ANGLE TO MOVE: "+cell_attrs.angle);
	double newX,newY;
	newX = (cell_loc.x + (movement_interval * Math.cos(angle_to_move)));
	newY = (cell_loc.y + (movement_interval * Math.sin(angle_to_move)));
	
	// check if the location needs to be rolled round the screen
	Double2D checkedLoc = rollAround(newX,newY);
	
	//System.out.println("CheckedLoc "+checkedLoc+" "+callingFunc);
	// return the checked position
	return checkedLoc;	
}
	
    
public static int set_ltin_contact_time()
{
	return (int)Mason_Sim_Main.state.schedule.getSteps();
}
	
    
public static double probability_responds_to_chemokine(Double2D cell_loc, double totalchemolevels, SortedMap<Double, Integer> chemomap)
{
	if (!Mason_Sim_Main.simParams.chemoKnockOut) {

		


		// System.out.println("TOTAL CHEMOKINE LEVELS: "+totalchemoLevels);

		// Now find the best move based on the chemokine levels around the cell

		// Adjuster - will determine the probability that the cell moves in the
		// direction of the highest chemokine strength
		// Calculated based on the presence of the three chemokines

		int adjuster = 0;

		// Now determine if the cell is in the amplification range (i.e. being affected
		// by the chemokine level)
		if (totalchemolevels > 0) {
			if (chemomap.lastKey() > Mason_Sim_Main.simParams.chemoThreshold) // there is a strong chemokine in
																					// this area, the probability
																					// increases
			{
				adjuster = chemomap.lastKey().intValue();

				/*if (cell_attrs.get_module_ref().traceOutput) {
					cell_attrs.get_module_ref().cell_trace.write_to_trace_file("Chemokine " + cell_attrs.chemomap.lastKey() + " Greater than Threshold "
							+ ppsim.simParams.chemoThreshold);
					cell_attrs.get_module_ref().cell_trace.write_to_trace_file("Adjuster: " + adjuster);
				}*/

				// get the strength of the chemokine (used to calculate the probability)
				// this is adjusted by a parameter which sets the strength of this chemokine
			}
		}

		return (adjuster);

	} else {
		return 0;
	}
}
	
    
public static double calculate_probability_adhesion(int contactedCell_ID)
{
	if(contactedCell_ID != -1)
	{
		// Get the contacted cell
		Object contactedCell = Mason_Sim_Main.agent_store.allCells.get(contactedCell_ID);
		
		// Calculate the VCAM probability here in the RoboCalc version
		double vcamMove = calculateVCAMEffect2((LTo_Module) contactedCell);
		//System.out.println("*** Contact. VCAM Probability: "+ vcamMove);
		return vcamMove;
	}
	else
	{
		return 0;
	}
}
	
    
public static int set_lti_contact_time()
{
	return (int)Mason_Sim_Main.state.schedule.getSteps();
}
	
    
public static double set_cell_speed(double random_num, double lower_bound, double upper_bound)
{
	return random_num * 
			(upper_bound - lower_bound) + lower_bound;
}
	
    
public static double avoidCellCollision(Double2D cell_loc, double distanceToMove, int contactedCell_ID)
{
	boolean collide = true;
	int numAttempts = 10;			// flag to make sure that an infinite loop is not created if no position found
	//double angle = 0.0;
	
	// To keep the rngs synced between this version and the original, generate an array of random numbers to try here
	ArrayList<Integer> random_ints = Mason_Sim_Main.generate_random_number_set();
	//System.out.println("Avoid Cell Collision, Distance to Move: "+distanceToMove);
	double new_angle = 0;
	
	// now try to find a move for the given number of attempts
	for(int j=0;j<numAttempts && collide;j++)
	{
		// NOW USE THE RANDOM NUMBER SET
		new_angle = Math.toRadians(random_ints.get(j));
		
		// work out where the cell would move to
		Double2D newPosition = calculateNewPosition(cell_loc, new_angle, distanceToMove);
		
		// Check for rollaround
		if(newPosition.y != Double.POSITIVE_INFINITY)
		{
			
			// get the cells that would be in contact in this new position
			Bag cellsInRange = Mason_Sim_Main.sim_env.tract.getObjectsExactlyWithinDistance(newPosition,((Mason_Sim_Main.simParams.HCELL_DIAMETER/2)+(Mason_Sim_Main.simParams.LTO_DIAMETER/2)));
			
			
			
			/*if(cell_attrs.traceOutput)
			{
				LTo_Module d = (LTo_Module) cell_state.contactedCell;
				cell_attrs.refToObject.write_to_trace_file("Contacted Cell ID: "+d.lto_Attrs.cellID);
				cell_attrs.refToObject.write_to_trace_file("Cells In Range");
				
				for(int i=0;i<cellsInRange.numObjs;i++)
				{
					Object c =  cellsInRange.get(i);
					if(c instanceof LTi_Module)
					{
						LTiModule l = (LTiModule) c;
						cell_attrs.refToObject.write_to_trace_file("LTi: "+((LTiModule) c).lti_Attrs.cellID);
					}
					else if(c instanceof LTinModule)
					{
						LTinModule l = (LTinModule) c;
						cell_attrs.refToObject.write_to_trace_file("LTin: "+((LTinModule) c).ltin_Attributes.cellID);
					}
					else
					{
						LToModule l = (LToModule) c;
						cell_attrs.refToObject.write_to_trace_file("LTo: "+((LToModule) c).lto_Attrs.cellID + " "+((LToModule) c).lto_Attrs.loc);
					}
				}
				
				cell_attrs.refToObject.write_to_trace_file("Attempting to move to: "+newPosition);
				cell_attrs.refToObject.write_to_trace_file("Size of cellsInRange: "+cellsInRange.numObjs);
							
			}*/
			
			// check whether the cell that was previously in contact is still in contact
			if(cellsInRange.contains(Mason_Sim_Main.agent_store.allCells.get(contactedCell_ID)))
			{
				collide = true;
			}
			else    // the new position is away from the cell
			{
				collide = false;	
				//System.out.println("Setting Collision to False After "+j+" tries");
			}
		}
	}
	
	if(collide)
	{
		// a new position could not be found in the number of attempts given
		// just move away at a random angle (that may still result in some contact unfortunately)
		new_angle = Math.toRadians( Mason_Sim_Main.rng.nextInt(360));
	}
	
	// return the angle so the move can be made
	return new_angle;
}
	
    
public static boolean check_valid_location_on_grid(Double2D cell_loc)
{
	if(cell_loc.y == Double.POSITIVE_INFINITY)
		return false;
	else
		return true;
}
	
/***************************************************************************************************************
 * OTHER FUNCTIONS USED BY THOSE GENERATED ABOVE:
 */

/**
* As get neighbours is toroidal, the algorithm may examine chemokine levels that roll around the right/left of screen.  It is right that it should consider
* top and bottom, but not left & right.  This stops this happening
* 
* @param ppsim	The current simulation state
* @param agentLocation	Where the LTi cell is
* @param xPosInNeighbourhood	It's x position in the Moore's Neighbourhood
* @return 	Boolean stating whether the level calculated has rolled round left to right
*/
	public static boolean checkChemokineRightLeftRollAround(Double2D agentLocation, Integer xPosInNeighbourhood)
	{
		// GET NEIGHBOURS IS TOROIDAL AS THE CELL MAY DIVIDE OVER THE TOP/BOTTOM OF SCREEN
		// HOWEVER THIS MEANS THE CELL WILL DIVIDE LEFT & RIGHT
		// THIS CANNOT HAPPEN AND NEEDS TO BE DETECTED
		
		// gather whether the cell is on the left hand or right hand edge of the tract (if either)
		if(Mason_Sim_Main.sim_env.chemoGrid.roundX(agentLocation.x) < ((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))/2)
		//if(this.gridLoc.x < ((int)(simParams.initialGridLength/simParams.LTO_DIAMETER))/2)	// on the left
		{
			if((xPosInNeighbourhood-Mason_Sim_Main.sim_env.chemoGrid.roundX(agentLocation.x))+1 < (int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else	// on the right
		{
			if((Mason_Sim_Main.sim_env.chemoGrid.roundX(agentLocation.x) - xPosInNeighbourhood)+1 < (int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	}
	
	public static int return_cell_id(Object temp)
	{
		if(temp instanceof LTin_Module)
		{
			return ((LTin_Module) temp).getLTin_Module_LTin_Step().LTin_Step_LTin_Attributes.cell_id;
		}
		else if(temp instanceof LTiModule)
		{
			return ((LTiModule) temp).getLTiModule_LTiStep().LTiStep_LTi_Attributes.cell_id;
		}	
		else if(temp instanceof LTo_Module)
		{
			return ((LTo_Module) temp).getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id;
		}
		else
		{
			// All being well this will be found when the cell is requested from the hashmap
			//System.out.println("Returning 99");
			return -99;
		}
	}
	
	public static Double2D rollAround(Double newX,Double newY)
	{
  	if(newY>Mason_Sim_Main.simParams.currentGridHeight)			// roll round so cell appears at top of screen
		{
  		// KA: New Y is now 0.1 so that when the chemokine rounds it up, it becomes 1, then -1 to 0 to give square num
			newY=0.5;
		}
		else if(newY<0.0)                      // roll round so appears at bottom
		{
			// 0.5 taken off the height for rounding reasons above
			newY=Mason_Sim_Main.simParams.currentGridHeight-0.5;
		}
	
  	if(newX>Mason_Sim_Main.simParams.currentGridLength || newX<0.0)   // if has left right or left, the cell is deemed dead, so stop from the schedule
  	{
  		// We're going to set newLoc to something that can be detected and stopped in the state machine
  		//System.out.println("setting positive infinity");
  		//System.out.println("Setting to positive infinity");
  		newY = Double.POSITIVE_INFINITY;
  		
  		
  		/*if(module_ref instanceof LTin_Module)
  		{
  			LTin_Module m = (LTin_Module) module_ref;
  			m.stopped = true;
  		}
  		else if(module_ref instanceof LTi_Module)
  		{
  			LTi_Module m = (LTi_Module) module_ref;
  			m.stopped = true;
  		} */
  			
  	}
  	
		Double2D newLoc = new Double2D(newX,newY);
		
		//System.out.println("Returning "+newLoc);
		return newLoc;
	}
	
	/**
   * Determines whether a LTin/LTi cell remains in contact with an LTo due to the level of VCAM being expressed by that 
   * cell.  If not the LTin/LTi will move away
   * @param ppsim	The current simulations state
   */
  public static double calculateVCAMEffect2(LTo_Module contactedCell)
  {
  	/// SECTION TAKEN FROM examineVCAMEffect OF PREVIOUS SIM CODE:
  	//LTo_Module ltoCell = (LTo_Module) cell_state.contactedCell;
  	double level_ProlongedAdhesion = Mason_Sim_Main.simParams.vcamSlope * contactedCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionExpressed;
  	
  	return level_ProlongedAdhesion;
  	
  	
  	// THE REST OF THIS METHOD IS NOW TAKEN CARE OF IN THE STATE MACHINE
  }
  
  /**
	 * As the tract has been modelled as 2D, with cells allowed to roll round top and bottom, the cells can potentially find a divide location 
	 * on the opposite side of the tract (left and right)- this checks that this does not happen
	 * 
	 * @param ppsim	The current simulation state
	 * @param dividingCell	The LTo cell object that is dividing
	 * @param xPosInNeighbourhood	The x position that has been found by the Moore's Neighborhood algorithm which needs checking to ensure it is not on opposite side
	 * @param distance	The distance away from the dividing cell that the cell is looking to divide to
	 * @return a boolean stating whether the location is valid or not
	 */
	public static boolean checkDivisionRightLeftRollAround(Int2D agentLocation,
			Integer xPosInNeighbourhood, int distance)
	{
		// GET NEIGHBOURS IS TOROIDAL AS THE CELL MAY DIVIDE OVER THE TOP/BOTTOM OF SCREEN
		// HOWEVER THIS MEANS THE CELL WILL DIVIDE LEFT & RIGHT
		// THIS CANNOT HAPPEN AND NEEDS TO BE DETECTED
		
		// gather whether the cell is on the left hand or right hand edge of the tract (if either)
		if(agentLocation.x < ((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))/2)	// on the left
		{
			if((xPosInNeighbourhood-agentLocation.x)+distance < (int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else	// on the right
		{
			if((agentLocation.x - xPosInNeighbourhood)+distance < (int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
			
	}
		
	/**
	 * Creates the duplicate of an existing LTo cell (i.e. simulating cell division)
	 * @param temp	The cell that is dividing
	 * @param ppsim	The current simulation state
	 * @return LTo ltoCell	The new LTo cell, sharing all properties of the original
	 */
	public static void makeNewLTo(double adhesionExpressed, double chemokineExpressed, boolean maxExpressionReached, LTo_Module newCell)
	{
		//System.out.println("Locations: "+dividingCell.lto_Attrs.loc +" " + newCell.lto_Attrs.loc);
		// Temporarily store the new cells locations
		Double2D tempLoc = newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc;
		//int tempId = newCell.lto_Attrs.cellID;
				
		// Copy properties over in robocalc version
		//newCell.lto_Attrs = dividingCell.lto_Attrs;
		try
		{
			newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionExpressed = adhesionExpressed;
			newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressed = chemokineExpressed;
			newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET = true;
			newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxExpressionReached = maxExpressionReached;
		
			// Set the correct location
			newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc = tempLoc;
			//newCellAttributes.cellID = tempId;
			
			Mason_Sim_Main.agent_store.ltoCellsBag.add(newCell);
			
			// Add to display
			Mason_Sim_Main.sim_env.tract.setObjectLocation(newCell, newCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc);
			
			newCell.setStopper(Mason_Sim_Main.state.schedule.scheduleRepeating(newCell,Mason_Sim_Main.agent_store.lto_scheduler_ref,1));
			Mason_Sim_Main.agent_store.lto_scheduler_ref++;
			
			//System.out.println("Chemokine: "+ dividingCell.lto_Attrs.chemokineExpressed+" "+newCell.lto_Attrs.chemokineExpressed);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		
		
	}
	
	/**
	 * Calculate the strength of the chemokine expression at a given distance from
	 * an LTo cell expressing the chemokines
	 * 
	 * @param distance
	 *            The distance of the cell from the LTo
	 * @param linearAdjust
	 *            The chemokine linear adjustment used to calculate how much
	 *            chemokine is being expressed
	 * @param chemoSigThresold
	 *            The value used to adjust the sigmoid function to sit correctly
	 *            between 1 and 0
	 * @param threshold
	 *            The threshold at which this chemokine affects the cell movement
	 * @return chemoEffect Level of expression at this distance
	 */
	public static double calcChemoLevel(double distance, double linearAdjust, double chemoSigThreshold,
			double threshold) {
		// calculate the chemokine effect at this distance
		double chemoEffect = (1 / (1 + Math.pow(Math.E, -(-linearAdjust * distance + chemoSigThreshold))));

		// check whether the chemokine effect is over the set threshold
		if (chemoEffect <= threshold) {
			return 0;
		} else {
			return chemoEffect;
		}
	}


}

