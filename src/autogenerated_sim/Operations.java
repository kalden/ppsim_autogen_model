package autogenerated_sim;

import autogenerated_sim.Functions;
import autogenerated_sim.LTiModule;
import autogenerated_sim.LTin_Module;
import autogenerated_sim.LTo_Module;
import simulation_main.Mason_Sim_Main;
import sim.util.Double2D;
import sim.util.Int2D;
import sim.util.IntBag;

public class Operations implements HardwareComponent {
	

	
	
	public Operations()
	{
	
	}
	
	public void update_tracking_stats(Tracking_Stats tracking, int cell_id, Double2D loc, double distanceMoved)
	{
		if(Mason_Sim_Main.simParams.cellTrackingEnabled)
		{
			// Get the cell being updated
			Object cell = Mason_Sim_Main.agent_store.allCells.get(cell_id);
			
			if(Mason_Sim_Main.agent_store.trackedCells_Away.contains(cell) || Mason_Sim_Main.agent_store.trackedCells_Close.contains(cell))
			{
				// only tracking each cell for an hour - do not update if past an hour 
				if(tracking.timeTracked<61)
				{
					// the cell is being tracked - need to update the length
					tracking.trackLength = tracking.trackLength + distanceMoved;
					//System.out.println("Length: "+tracking.trackLength);
					tracking.trackLengthScaled = tracking.trackLength*4;
					tracking.trackedVelocity = tracking.trackLengthScaled/60;
					//System.out.println("Velocity: "+tracking.trackedVelocity);
					tracking.timeTracked++;
						
					/*if(cell_attrs.traceOutput)
					{
						cell_attrs.refToObject.write_to_trace_file("Moved: "+distanceMoved+" Length: "+cell_attrs.trackLength+" Velocity: "+cell_attrs.trackedVelocity+" Time: "+cell_attrs.timeTracked);
					}*/
						
					// KA: Seeing if we can fix the error in the original here to see if it makes any difference - the end of track should have been set here
					// Note 61 for robocalc version: first step is intialisation
					if(tracking.timeTracked==61)
					{
						tracking.agentTrackEndLocation = loc;
					}
		
				}
					// Commented out while determine if this error can be fixed
					/*else if(cell_attrs.timeTracked == 60)
					{
						// add the end point to work out displacement
						cell_attrs.agentTrackEndLocation = cell_attrs.loc;
						
						if(cell_attrs.traceOutput)
						{
							cell_attrs.refToObject.write_to_trace_file("Moved: "+distanceMoved+" Length: "+cell_attrs.trackLength+" Velocity: "+cell_attrs.trackedVelocity+" Time: "+cell_attrs.timeTracked);
						}
					}*/
				}
		}
	}
	
	public void setPositionOnTract(int cell_id, Double2D cell_loc)
	{
		Object cell = Mason_Sim_Main.agent_store.allCells.get(cell_id);
		Mason_Sim_Main.sim_env.tract.setObjectLocation(cell, cell_loc);
	}
	
	public void stop_cell_on_schedule(int cell_id)
	{
		Object cell = Mason_Sim_Main.agent_store.allCells.get(cell_id);
		if(cell instanceof LTin_Module)
			((LTin_Module)cell).stop();
		else if(cell instanceof LTiModule)
			((LTiModule)cell).stop();
		else if(cell instanceof LTo_Module)
			((LTo_Module)cell).stop();
	}
	
	public void divide_cells(Int2D gridLoc, double adhesionExpressed, double chemokineExpressed, boolean maxExpressionReached, int distance, String entry_state)
	{
		//System.out.println("Dividing Cell "+cell_attrs.cell_id);
		// convertDone - flag to show if an inactive cell has been found to be converted or not
		boolean convertDone = false;
		
		Int2D blankSpace = null;
		
		// Need to get the LTo Cells that are around itd
		IntBag xPos = new IntBag();
		IntBag yPos = new IntBag();
		
		//System.out.println("Cell At: "+cell_attrs.gridLoc.x+" "+cell_attrs.gridLoc.y);
		
		// get the cells that are in the lto grid squares around this
		Mason_Sim_Main.sim_env.lToGrid.getNeighborsMaxDistance(gridLoc.x, gridLoc.y, distance, true, xPos, yPos);
		//System.out.println(xPos.size()+" "+yPos.size());
		
		// Now got through attempting to find an immature LTo that can be converted(or blank square if necessary for later!)
		
		// Now go through each grid in the neighbourhood, excluding the centre where the cell is
		for(int k=0;k<xPos.size() && !convertDone;k++)
		{	
			// FIX TO STOP DIVISION OVER RIGHT/LEFT OF SCREEN
			// CHECK THE LOCATION IS NOT ON THE OTHER SIDE OF THE TRACT
			// To check this, take the x grid location of where the cell wants to move, subtract the location of where the cell is (if on left,
			// if on right side swap them over), add the distance the cell wants to move, and check this is greater than the upper limit of the tract
			boolean moveOk = Functions.checkDivisionRightLeftRollAround(gridLoc, xPos.get(k), distance);
			//System.out.println(xPos.get(k)+" "+yPos.get(k)+" Move Ok: "+moveOk);
				
			if(moveOk)
			{
				LTo_Module stromalCell = (LTo_Module)Mason_Sim_Main.sim_env.lToGrid.get(xPos.get(k),yPos.get(k));
			
				if(stromalCell!=null && !stromalCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.expressingRET)			// this is an LTo cell can be converted
				{
					// need to copy properties of dividing cell to this cell
					Functions.makeNewLTo(adhesionExpressed, chemokineExpressed, maxExpressionReached, stromalCell);
					convertDone = true;
				}
			
				if(stromalCell==null && blankSpace==null)			// this is a free space and can therefore be filled with an LTo
				{
					blankSpace = new Int2D(xPos.get(k),yPos.get(k));
				}
			}
			
		}
		
		// Now need to check a cell has been created - if not (there were no inactive cells around to convert), need to create a new one
		if(!convertDone)
		{
			if(blankSpace!=null)
			{
				// take the first empty grid space that was found & place an LTo there
				// work out where this square represents on the grid (as the intestine itself will have grown, so the squares will be a different
				// size to originally
				
				// work out the size of each grid square
				double xAdj = Mason_Sim_Main.simParams.currentGridLength / ((int)(Mason_Sim_Main.simParams.initialGridLength/Mason_Sim_Main.simParams.LTO_DIAMETER));
				double yAdj = Mason_Sim_Main.simParams.currentGridHeight / ((int)(Mason_Sim_Main.simParams.initialGridHeight/Mason_Sim_Main.simParams.LTO_DIAMETER));
			
				// store the location
				Double2D location = new Double2D((blankSpace.x*xAdj)+Mason_Sim_Main.simParams.LTO_DIAMETER/2,(blankSpace.y*yAdj)+Mason_Sim_Main.simParams.LTO_DIAMETER/2);
				
				// set the ltoCell to be at this location
				//LTo ltoCell = new LTo(location, new Int2D(blankSpace.x, blankSpace.y),ppsim);
				
				LTo_Module ltoCell = new LTo_Module();
				ltoCell.Init();
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.entry_state = entry_state;
				
				// Initialise variables
				// Set the parameters in the model. Maybe this should be somewhere else
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionExpressed = 0;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressed = Mason_Sim_Main.simParams.chemoUpperLinearAdjust;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxVCAMProbability = Mason_Sim_Main.simParams.maxVCAMProbability;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.retLigandTime = Mason_Sim_Main.simParams.numHoursRETLigandLToActive;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.maxExpressionReached = false;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.adhesionIncrement = 0.05;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineDecrement = 0.005;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.chemokineExpressionLimit = Mason_Sim_Main.simParams.chemoLowerLinearAdjust;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cellDivisionTime = Mason_Sim_Main.simParams.cellDivisionTime;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id = Mason_Sim_Main.agent_store.num_cells_created;
				Mason_Sim_Main.agent_store.num_cells_created++;
				Mason_Sim_Main.agent_store.allCells.put(ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.cell_id, ltoCell);
				
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.LTo_loc = location;
				ltoCell.getLTo_Module_LTo_Step().LTo_Step_LTo_Attributes.gridLoc = new Int2D(blankSpace.x, blankSpace.y);
				
				// copy the properties of the dividing LTo cell to the new cell
				Functions.makeNewLTo(adhesionExpressed, chemokineExpressed, maxExpressionReached, ltoCell);
				
				//System.out.println("New LTo "+ltoCell.lto_Attrs.loc);

				// add to the storage and display
				// Seems LTo is added to Bag in makeNewLTo
				//ppsim.ltoCellsBag.add(ltoCell);
				
				Mason_Sim_Main.sim_env.lToGrid.set(blankSpace.x,blankSpace.y, ltoCell);
				// Added to tract in makeNewLTo
				//ppsim.tract.setObjectLocation(ltoCell,location);
				//ltoCell.setStopper(ppsim.schedule.scheduleRepeating(ltoCell));		
				
			}
			else
			{
				// there were no blank squares around, need to look further afield for a free location
				divide_cells(gridLoc, adhesionExpressed, chemokineExpressed, maxExpressionReached, distance+1, entry_state);
			}
		}
	}
	

	public void Sensors()
	{
		
	}
	public void Actuators()
	{
		
	}



}
