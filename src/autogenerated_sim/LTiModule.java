package autogenerated_sim;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;

import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.portrayal.DrawInfo2D;
import sim.portrayal.SimplePortrayal2D;
import simulation_main.Mason_Sim_Main;

public class LTiModule extends SimplePortrayal2D implements Steppable, Stoppable {

	private LTiController LTiModule_LTiController;
	private LTiStep LTiModule_LTiStep;
	
	// For MASON specific sims, need these attributes
	/**
	 * Flag to show that the LTo has been removed as this did not differentiate by a set time
	 */
	public boolean stopped = false;
		
	// KA: For MASON we need to be able to stop the cell, so the below needs to be added
	/**
	 * Flag to show if this class has been stopped (when no longer needed)
	 */
	public Stoppable stopper = null;
	    
	/**
	 * Method to change the value of the stopper
	 * @param stopper	Whether the class should be stopped or not
	 */
	public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
	    
	/**
	* Method to stop the class where necessary
	*/
	public void stop(){
		stopped = true;
	   	stopper.stop();
	}
	
	/**
	* Getter for robotic platform containing the step
	*/ 
	

	public LTiModule()
	{
		this.LTiModule_LTiController = null;
		
		
		// KA: Moved Robotic Platform into constructor, as needs to be initialised before state machine	
	this.LTiModule_LTiStep = new LTiStep ();
		
		}


public LTiStep getLTiModule_LTiStep()
{
	return this.LTiModule_LTiStep;
}

	public void Init() {
		this.LTiModule_LTiController = new LTiController (LTiModule_LTiStep);
		LTi_State_Machine LTiController_LTi_State_Machine = new LTi_State_Machine(LTiModule_LTiStep, LTiModule_LTiController);
		LTiModule_LTiController.stm = LTiController_LTi_State_Machine;
	}

	public void Execute() {
		this.LTiModule_LTiStep.Sensors();
		this.LTiModule_LTiController.Execute();
		this.LTiModule_LTiStep.Actuators();
	}

	
	public void step(SimState state)
	{
		// MASON step method. Should call Execute, but may do other operations that need specifying in here
		if(state.schedule.getSteps() > 0)
			//{
				//System.out.println(ppsim.schedule.getSteps());
			
			//if(ppsim.schedule.getSteps() < (PPsim_robocalc_main.simParams.simulationTime*60))
				if(state.schedule.getSteps() < (Mason_Sim_Main.simParams.simulationTime))
			{
				//System.out.println(ppsim.schedule.getSteps()+" "+PPsim_robocalc_main.inTrackingPeriod);
				//if(this.lti_Attrs.cellID == 140)
				//{
					//System.out.println(this.lti_Attrs.cellID);
				//}
				////////////////DELETE AFTER TESTING
				// For testing, we're going to restart the cells in their original place at step two
				/*if(PPsim_robocalc_main.remove_probabilities && ppsim.schedule.getSteps() == 2)
				{
					lti_Attrs.loc = lti_Attrs.originalLocation;
					lti_Attrs.ppsim.tract.setObjectLocation(lti_Attrs.refToObject, lti_Attrs.loc);
					lti_Attrs.trackLength = 0;
					lti_Attrs.timeTracked = 0;
					
				} */
					LTiModule_LTiStep.LTiStep_LTi_Attributes.tracking.agentPreviousLocation = LTiModule_LTiStep.LTiStep_LTi_Attributes.LTi_loc;
				
				
				
				//if(ppsim.trace_files_output)
				//{
					
					//if(PPsim_robocalc_main.inTrackingPeriod && PPsim_robocalc_main.trackedCells_Close.contains(lti_Attrs.refToObject) 
					//		&& this.close_behaviour_writer != null)
					///if(PPsim_robocalc_main.inTrackingPeriod && this.close_behaviour_writer != null)
					//{
						//System.out.println("Step: "+ppsim.schedule.getSteps()+" inTrackingPeriod "+PPsim_robocalc_main.inTrackingPeriod);
					//this.traceOutput = true;
					//}
				//}
				
				
				// Need to check the LTi has not left the grid - if it hasn't step, if not this object should be stopped
				if(!this.stopped)
				{
					
					if(Mason_Sim_Main.simParams.cellTrackingEnabled)
					{
						if(state.schedule.getSteps() == (Mason_Sim_Main.simParams.trackingSnapStartHr*60))
						{
							LTiModule_LTiStep.LTiStep_LTi_Attributes.tracking.agentTrackStartLocation = LTiModule_LTiStep.LTiStep_LTi_Attributes.LTi_loc;
						}
						//if(ppsim.schedule.getSteps()==((60/simParams.secondsPerStep)*(simParams.trackingSnapEndHr*60)))
						if(state.schedule.getSteps() ==(Mason_Sim_Main.simParams.trackingSnapEndHr*60))
						{
							LTiModule_LTiStep.LTiStep_LTi_Attributes.tracking.agentTrackEndLocation = LTiModule_LTiStep.LTiStep_LTi_Attributes.LTi_loc;
						}
					}
					
					/*if(this.traceOutput)
					{
						
						//System.out.println("TRACING OUTPUT");
						cell_trace.write_step_to_trace_file(ppsim.schedule.getSteps());
						cell_trace.write_start_location_to_trace_file(lti_module_lti_step.lti_loc);
						cell_trace.write_to_trace_file("LTI CELL "+ppsim.schedule.getSteps());
						if(ppsim.schedule.getSteps() > 1)
						{
							cell_trace.write_position_to_coords_file(ppsim.schedule.getSteps(), lti_module_lti_step.lti_loc);
						}
					}*/
					
					// KA: As steppable must call step, here we set step just to call Execute
					Execute();
					
					/*if(this.traceOutput)
						cell_trace.flush_buffers();*/
					
					//System.out.println("");
					/*if(ppsim.schedule.getSteps()==(PPsim_robocalc_main.stop_step-1) && lti_Attrs.traceOutput)
					{
						this.end_close_trace_file();
					}
					*/
					// Output some stats on this step, for testing:
					//System.out.println(ppsim.schedule.getSteps()+","+lti_Attrs.agentPreviousLocation.x+","+lti_Attrs.agentPreviousLocation.y+","+lti_Attrs.loc.x+","+lti_Attrs.loc.y);
					/*if(ppsim.schedule.getSteps()<50)
					{
						writer.println(ppsim.schedule.getSteps()+","+lti_Attrs.agentPreviousLocation.x+","+lti_Attrs.agentPreviousLocation.y+","+lti_Attrs.loc.x+","+lti_Attrs.loc.y);
					}
					else if(ppsim.schedule.getSteps()==50)
					{
						writer.close();
					}*/
						
					
					
					
				}
				else		// the cell has left the right or left of the screen/tract and will be stopped and removed from the simulation
				{
					//System.out.println("LTI BEING REMOVED");
					Mason_Sim_Main.sim_env.tract.remove(this);
					this.stop();
					// decrease the cellularity
					//ppsim.lTiCellularity--;
					//lti_Attrs.writer.close();
				
					// Remove from all tracking
					if(Mason_Sim_Main.simParams.cellTrackingEnabled)
					{
						if(Mason_Sim_Main.agent_store.trackedCells_Away.contains(this))
						{
							Mason_Sim_Main.agent_store.trackedCells_Away.remove(this);
							//System.out.println("Removing Cell "+this.lti_Attrs.cellID);
						}
						if(Mason_Sim_Main.agent_store.trackedCells_Close.contains(this))
						{
							Mason_Sim_Main.agent_store.trackedCells_Close.remove(this);
							//System.out.println("Removing Cell "+this.lti_Attrs.cellID);
							
							// If this happens during cell tracking (which is unlikely but possible) trace file will not have been closed
							// Close the trace file used to debug close be
							/*if(ppsim.trace_files_output)
								cell_trace.end_close_trace_file();*/
							
						}
					}
				
					Mason_Sim_Main.agent_store.allLTis.remove(this);
				}
			}
			else
			{
				
				/*if(PPsim_robocalc_main.trace_files_output && this.close_behaviour_coords!=null)
				{*/
					//System.out.println("HERE");
				//cell_trace.end_close_trace_file();
				//}
				this.stopped = true;
				this.stop();
				
				// If reached here, the debug trace files should already have been closed in cell tracking
				
			}		
	}
	
	// If outputting the simulation as a GUI, draw function is also required here
	/**
	 * Used by the graphic console to draw the cell to the screen
	 */
	public final void draw(Object object, Graphics2D graphics, DrawInfo2D info)
    {
		// KA new MASON requires the scale from the display object now to scale the cells right
		double diamx = Mason_Sim_Main.display.getScale() * Mason_Sim_Main.simParams.HCELL_DIAMETER;
		double diamy = Mason_Sim_Main.display.getScale() * Mason_Sim_Main.simParams.HCELL_DIAMETER;
		// Note multiplied by info - this ensures the diameter grows as the zoom function is used
		//double diamx = info.draw.width*PPsim_robocalc_main.simParams.HCELL_DIAMETER;
		//double diamy = info.draw.height*PPsim_robocalc_main.simParams.HCELL_DIAMETER;
	
		graphics.setColor(Color.CYAN);
		Ellipse2D.Double cell = new Ellipse2D.Double((int)info.draw.x-diamx/2,(int)info.draw.y-diamy/2,(int)diamx,(int)diamy);
        graphics.fill(cell);
    }
	}
