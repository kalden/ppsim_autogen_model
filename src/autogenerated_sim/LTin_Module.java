package autogenerated_sim;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;

import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.portrayal.DrawInfo2D;
import sim.portrayal.SimplePortrayal2D;
import simulation_main.Mason_Sim_Main;

public class LTin_Module extends SimplePortrayal2D implements Steppable, Stoppable {

	private LTin_Controller LTin_Module_LTin_Controller;
	private LTin_Step LTin_Module_LTin_Step;
	
	// For MASON specific sims, need these attributes
	/**
	 * Flag to show that the LTo has been removed as this did not differentiate by a set time
	 */
	public boolean stopped = false;
		
	// KA: For MASON we need to be able to stop the cell, so the below needs to be added
	/**
	 * Flag to show if this class has been stopped (when no longer needed)
	 */
	public Stoppable stopper = null;
	    
	/**
	 * Method to change the value of the stopper
	 * @param stopper	Whether the class should be stopped or not
	 */
	public void setStopper(Stoppable stopper)   {this.stopper = stopper;}
	    
	/**
	* Method to stop the class where necessary
	*/
	public void stop(){
		stopped = true;
	   	stopper.stop();
	}
	
	/**
	* Getter for robotic platform containing the step
	*/ 
	

	public LTin_Module()
	{
		this.LTin_Module_LTin_Controller = null;
		
		
		// KA: Moved Robotic Platform into constructor, as needs to be initialised before state machine	
	this.LTin_Module_LTin_Step = new LTin_Step ();
		
		}


public LTin_Step getLTin_Module_LTin_Step()
{
	return this.LTin_Module_LTin_Step;
}

	public void Init() {
		this.LTin_Module_LTin_Controller = new LTin_Controller (LTin_Module_LTin_Step);
		LTin_State_Machine LTin_Controller_LTin_State_Machine = new LTin_State_Machine(LTin_Module_LTin_Step, LTin_Module_LTin_Controller);
		LTin_Module_LTin_Controller.stm = LTin_Controller_LTin_State_Machine;
	}

	public void Execute() {
		this.LTin_Module_LTin_Step.Sensors();
		this.LTin_Module_LTin_Controller.Execute();
		this.LTin_Module_LTin_Step.Actuators();
	}

	
	public void step(SimState state)
	{
		// MASON step method. Should call Execute, but may do other operations that need specifying in here
		if(state.schedule.getSteps() > 0)
 		{
 
			
 		if(state.schedule.getSteps() < (Mason_Sim_Main.simParams.simulationTime))
 		{
 			LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.tracking.agentPreviousLocation = LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.LTin_loc;
 			
 			/*if(ppsim.trace_files_output)
 			{
 				//if(PPsim_robocalc_main.inTrackingPeriod && PPsim_robocalc_main.trackedCells_Close.contains(ltin_Attributes.refToObject) && this.close_behaviour_writer != null)
 				if(ppsim.cellTrackStats.inTrackingPeriod && cell_trace.close_behaviour_writer != null)
 				{
 					//System.out.println("Step: "+ppsim.schedule.getSteps()+" inTrackingPeriod "+PPsim_robocalc_main.inTrackingPeriod);
 					this.traceOutput = true;
 				}
 			}*/
 			
 		// Need to check the LTi has not left the grid - if it hasn't step, if not this object should be stopped
 			if(!this.stopped)
 			{
 				if(Mason_Sim_Main.simParams.cellTrackingEnabled)
 				{
 					//if(ppsim.schedule.getSteps()==((60/simParams.secondsPerStep)*(simParams.trackingSnapStartHr*60)))
 					if(state.schedule.getSteps() == (Mason_Sim_Main.simParams.trackingSnapStartHr*60))
 					{
 						LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.tracking.agentTrackStartLocation = LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.LTin_loc;
 	
 					}
 					//if(ppsim.schedule.getSteps()==((60/simParams.secondsPerStep)*(simParams.trackingSnapEndHr*60)))
 					if(state.schedule.getSteps() ==(Mason_Sim_Main.simParams.trackingSnapEndHr*60))
 					{
 						LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.tracking.agentTrackEndLocation = LTin_Module_LTin_Step.LTin_Step_LTin_Attributes.LTin_loc;
 						
 					}
 				}
 				
 				/*if(this.traceOutput)
 				{
 					cell_trace.write_step_to_trace_file(ppsim.schedule.getSteps());
 					cell_trace.write_start_location_to_trace_file(ltin_module_ltin_step.ltin_loc);
 					cell_trace.write_to_trace_file("LTIN CELL");
 					if(ppsim.schedule.getSteps() >= 1)
 					{
 						cell_trace.write_position_to_coords_file(ppsim.schedule.getSteps(), ltin_module_ltin_step.ltin_loc);
 					}
 				}*/
 				
 				//System.out.println("EXECUTE CALLED HERE");
 				Execute();
 				/*if(this.traceOutput)
 					cell_trace.flush_buffers();*/
 				
 			}
 			else		// the cell has left the right or left of the screen/tract and will be stopped and removed from the simulation
 			{
 				//System.out.println("Stopping LTin: "+this.ltin_Attributes.cellID);
 				
 				Mason_Sim_Main.sim_env.tract.remove(this);
 				this.stop();
 				// decrease the cellularity
 				//ppsim.lTinCellularity--;
 			
 				// Remove from all tracking
 				if(Mason_Sim_Main.simParams.cellTrackingEnabled)
 				{
 					if(Mason_Sim_Main.agent_store.trackedCells_Away.contains(this))
 						Mason_Sim_Main.agent_store.trackedCells_Away.remove(this);
 					if(Mason_Sim_Main.agent_store.trackedCells_Close.contains(this))
 					{
 						Mason_Sim_Main.agent_store.trackedCells_Close.remove(this);
 						
 						// If this happens during cell tracking (which is unlikely but possible) trace file will not have been closed
 						// Close the trace file used to debug close be
 						/*if(this.traceOutput)
 						{
 							cell_trace.end_close_trace_file();
 						}*/
 					}
 				}
 				
 			
 				Mason_Sim_Main.agent_store.allLTins.remove(this);
 			}
 		}
 		else
 		{
 			
 			this.stopped = true;
 			this.stop();
 			//cell_trace.end_close_trace_file();
 		}
 		
 		}
		
		
	}
	
	// If outputting the simulation as a GUI, draw function is also required here
	public final void draw(Object object, Graphics2D graphics, DrawInfo2D info)
    {
    	// KA new MASON requires the scale from the display object now to scale the cells right
		double diamx = Mason_Sim_Main.display.getScale() * Mason_Sim_Main.simParams.HCELL_DIAMETER;
		double diamy = Mason_Sim_Main.display.getScale() * Mason_Sim_Main.simParams.HCELL_DIAMETER;
		// Note multiplied by info - this ensures the diameter grows as the zoom function is used
		//double diamx = info.draw.width*PPsim_robocalc_main.simParams.HCELL_DIAMETER;
		//double diamy = info.draw.height*PPsim_robocalc_main.simParams.HCELL_DIAMETER;
	
		graphics.setColor(Color.red);
		Ellipse2D.Double cell = new Ellipse2D.Double((int)info.draw.x-diamx/2,(int)info.draw.y-diamy/2,(int)diamx,(int)diamy);
        graphics.fill(cell);
    }
	}
